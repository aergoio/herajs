import { ec } from 'elliptic';
import { AES_GCM } from 'asmcrypto.js';
import { fromNumber, fromBigInt, encodeAddress, decodeAddress, encodePrivateKey, decodePrivateKey } from './encoding';
import 'regenerator-runtime/runtime';

const ecdsa = new ec('secp256k1');

/**
 * Shortcut function to create a new random private key and
 * return keys and address as encoded strings.
 */
const createIdentity = () => {
    const keyPair = ecdsa.genKeyPair();
    return encodeIdentity(keyPair);
};

/**
 * Returns identity associated with private key
 * @param {Uint8Array} privKeyBytes 
 */
const identifyFromPrivateKey = (privKeyBytes) => {
    const keyPair = ecdsa.keyFromPrivate(privKeyBytes);
    return encodeIdentity(keyPair);
};

/**
 * Encodes a key pair into an identity object
 * @param {KeyPair} keyPair 
 * @return {object}
 */
const encodeIdentity = (keyPair) => {
    const privateKey = keyPair.getPrivate();
    const publicKey = keyPair.getPublic();
    const address = addressFromPublicKey(publicKey);
    return {
        address,
        publicKey,
        privateKey,
        keyPair
    };
};

/**
 * Encode public key as address
 * @param {ECPoint} publicKey
 * @return {string} base58check encoded address
 */
const addressFromPublicKey = (publicKey) => {
    const len = publicKey.curve.p.byteLength();
    const x = publicKey.getX().toArray('be', len);
    const address = [ publicKey.getY().isEven() ? 0x02 : 0x03 ].concat(x);
    return encodeAddress(address);
};

/**
 * Retrieve public key from address
 * @param {ECPoint} publicKey
 * @return {string} base58check encoded address
 */
const publicKeyFromAddress = (address) => {
    const pubkey = decodeAddress(address);
    return ecdsa.keyFromPublic(pubkey);
};

/**
 * Sign transaction with key.
 * @param {object} tx transaction
 * @param {BN} key key pair or private key
 */
const signTransaction = async (tx, key) => {
    const msgHash = await hashTransaction(tx, 'bytes', false);
    const sig = key.sign(msgHash);
    return encodeSignature(sig);
};

/**
 * Calculate hash of transaction
 * @param {object} tx Transaction
 * @return {string} transaction hash
 */
const hashTransaction = async (tx, encoding = 'base64', includeSign = true) => {
    // check amount format
    const amountUnit = tx.amount.match(/\s*([^0-9]+)\s*/);
    if (amountUnit && amountUnit[1] !== 'aer') {
        throw Error(`Can only hash amounts provided in the base unit (aer), not ${tx.amount}. Convert to aer or remove unit.`);
    }
    tx.amount = tx.amount.replace(/[^0-9]/g, '');

    const h = ecdsa.hash();
    let data = Buffer.concat([
        fromNumber(tx.nonce, 64),
        decodeAddress(tx.from),
        decodeAddress(tx.to),
        fromBigInt(tx.amount || 0),
        Buffer.from(tx.payload),
        fromNumber(tx.limit, 64),
        fromBigInt(tx.price || 0),
        fromNumber(tx.type, 32)
    ]);

    if (includeSign && 'sign' in tx) {
        data = Buffer.concat([data, Buffer.from(tx.sign, 'base64')]);
    }

    h.update(data);

    if (encoding == 'base64') {
        return Buffer.from(h.digest()).toString('base64');
    } else {
        return h.digest();
    }
};

/**
 * Verify that a signature for tx was generated by key
 */
const verifyTxSignature = async (tx, key, signature) => {
    const msg = await hashTransaction(tx, 'bytes', false);
    return await verifySignature(msg, key, signature);
};

/**
 * Verify that a signature for msg was generated by key
 */
const verifySignature = async (msg, key, signature) => {
    try {
        const sign = Buffer.from(signature, 'base64');
        return key.verify(msg, sign);
    } catch (e) {
        throw Error('Could not decode signature. ' + e);
    }
};

const _keyAndNonceFromPassword = async (password) => {
    // Make a key from double hashing the password
    const hash = ecdsa.hash();
    hash.update(password);
    const addr = hash.digest();
    const rehash = ecdsa.hash();
    rehash.update(password);
    rehash.update(addr);
    const key = Buffer.from(rehash.digest());
    const nonce = Buffer.from(addr.slice(4, 16));
    return [key, nonce];
};

const decryptPrivateKey = async (encryptedBytes, password) => {
    const [key, nonce] = await _keyAndNonceFromPassword(password);
    return AES_GCM.decrypt(encryptedBytes, key, nonce);
};

const encryptPrivateKey = async (clearBytes, password) => {
    const [key, nonce] = await _keyAndNonceFromPassword(password);
    return AES_GCM.encrypt(clearBytes, key, nonce);
};

const encodeSignature = (sig) => {
    return Buffer.from(sig.toDER()).toString('base64');
};

export {
    createIdentity,
    identifyFromPrivateKey,
    addressFromPublicKey,
    publicKeyFromAddress,
    encodeAddress,
    decodeAddress,
    signTransaction,
    hashTransaction,
    verifySignature,
    verifyTxSignature,
    decryptPrivateKey,
    encryptPrivateKey,
    encodePrivateKey,
    decodePrivateKey,
};